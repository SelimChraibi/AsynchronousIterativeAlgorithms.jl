<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · AsynchronousIterativeAlgorithms.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.gif" alt="AsynchronousIterativeAlgorithms.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Working-with-a-distributed-problem"><span>Working with a distributed problem</span></a></li><li><a class="tocitem" href="#Synchronous-run"><span>Synchronous run</span></a></li><li><a class="tocitem" href="#Active-processes"><span>Active processes</span></a></li><li><a class="tocitem" href="#recording_iterated"><span>Recording iterates</span></a></li><li><a class="tocitem" href="#custom_execution"><span>Customization of <code>start</code>&#39;s execution</span></a></li><li><a class="tocitem" href="#Handling-worker-failures"><span>Handling worker failures</span></a></li><li><a class="tocitem" href="#algorithm_wrappers"><span>Algorithm wrappers</span></a></li></ul></li><li><a class="tocitem" href="../documentation/">Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Selim78/AsynchronousIterativeAlgorithms.jl/blob/main/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>We saw how to run an asynchronous version of the SGD algorithm on a LRMSE problem in <a href="../#quick_start">quick start</a>. Here we&#39;ll use this same example to look at the following:  </p><ul><li><a href="#Working-with-a-distributed-problem">Working with a distributed problem</a></li><li><a href="#Synchronous-run">Synchronous run</a></li><li><a href="#Active-processes">Active processes</a></li><li><a href="#recording_iterated">Recording iterates</a></li><li><a href="#custom_execution">Customization of <code>start</code>&#39;s execution</a></li><li><a href="#Handling-worker-failures">Handling worker failures</a></li><li><a href="#algorithm_wrappers">Algorithm wrappers</a></li></ul><h2 id="Working-with-a-distributed-problem"><a class="docs-heading-anchor" href="#Working-with-a-distributed-problem">Working with a distributed problem</a><a id="Working-with-a-distributed-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-a-distributed-problem" title="Permalink"></a></h2><p>Suppose you have a <code>make_problem</code> function</p><pre><code class="language-julia hljs"># Note: In this example, we sample `A` and `b`. 
# In practice, we could read them from a file or any other source.
@everywhere function make_problem(pid)
    pid==1 &amp;&amp; return nothing # for now, let&#39;s assign process 1 an empty problem
    LRMSE(rand(pid,10),rand(pid)) # the sample size is `m` is set to `pid` for demonstration purposes only
end</code></pre><p>When instantiating your problems you might have three requirements:</p><ul><li><strong>Limiting communication costs</strong> and <strong>avoiding duplicated memory</strong>: loading problems directly on their assigned processes is preferable to loading them central node before sending them to their respective processes</li><li><strong>Persistent data</strong>: necessary if you want to reuse problems for multiple experiments (you don&#39;t want your problems to be stuck on  remote processes in <code>start</code>&#39;s local scope)</li></ul><p>Depending on your needs, you have three options to construct your problems:</p><pre><code class="language-julia hljs"># Option 1: Instantiate the problems remotely
problem_constructor = make_problem 

# Option 2: Instantiate the problems on the central node and send them to their respective processes
problems = Dict(procs() .=&gt; make_problem.(procs()));
problem_constructor = (pid) -&gt; problems[pid]

# Option 3: Create a `DistributedObject` that references a problem on each process. 
@everywhere using DistributedObjects
distributed_problem = DistributedObject((pid) -&gt; make_problem(pid), pids=procs())</code></pre><blockquote><p>Option 3 uses <a href="https://github.com/Selim78/DistributedObjects.jl"><code>DistributedObjects</code></a>. In a nutshell, a <code>DistributedObject</code> instance references at most one object per process, and you can access the object stored on the current process with <code>[]</code></p></blockquote><table><tr><th style="text-align: right"></th><th style="text-align: center">communication costs &amp; duplicated memory</th><th style="text-align: center">single use objectives</th><th style="text-align: right"></th></tr><tr><td style="text-align: right">Option 1</td><td style="text-align: center"></td><td style="text-align: center">❌</td><td style="text-align: right"><img src="../assets/option_1.png" alt/></td></tr><tr><td style="text-align: right">Option 2</td><td style="text-align: center">❌</td><td style="text-align: center"></td><td style="text-align: right"><img src="../assets/option_2.png" alt/></td></tr><tr><td style="text-align: right">Option 3</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: right"><img src="../assets/option_3.png" alt/></td></tr></table><p>As previously noted, Option 2 should be avoided when working with large data. However, it does offer the advantage of preserving access to problems, which is not possible with Option 1. This opens up the possibility of reconstructing the global problem.</p><pre><code class="language-julia hljs"># reconstructing global problem from problems stored locally
function LRMSE(problems::Dict)
    pids = [pid for pid in keys(problems) if pid ≠ 1]
    n = problems[pids[1]].n
    m = sum([problems[pid].m for pid in pids])
    L = sum([problems[pid].L for pid in pids])
    ∇f(x) = sum([problems[pid].∇f(x) * problems[pid].m for pid in pids]) / m
    return LRMSE(nothing,nothing,n,m,L,∇f)
end

problems[1] = LRMSE(problems);
# We now have access to the global Lipschitz constant!
sgd = SGD(1/problems[1].L)</code></pre><p><em>Option 3</em> is the best of both worlds:</p><pre><code class="language-julia hljs"># reconstructing global problem from problems stored remotely 
function LRMSE(d::DistributedObject)
    pids = [pid for pid in where(d) if pid ≠ 1]
    n = fetch(@spawnat pids[1] d[].n)
    m = sum(fetch.([@spawnat pid d[].m for pid in pids]))
    L = sum(fetch.([@spawnat pid d[].L for pid in pids]))
    ∇f(x) = sum(fetch.([@spawnat pid d[].∇f(x) * d[].m for pid in pids])) / m
    return LRMSE(nothing,nothing,n,m,L,∇f)
end

distributed_problem[] = LRMSE(distributed_problem);
# We also have access to the global Lipschitz constant!
sgd = SGD(1/distributed_problem[].L)</code></pre><p>It&#39;s worth mentioning that instead of <code>problem_constructor::Function</code>, <code>distributed_problem::DistributedObject</code> can be passed to <a href="../documentation/#AsynchronousIterativeAlgorithms.start"><code>start</code></a>. Both of the following are equivalent:</p><pre><code class="language-julia hljs">history = start(sgd, (pid)-&gt; distributed_problem[], stopat)
history = start(sgd, distributed_problem, stopat);</code></pre><h2 id="Synchronous-run"><a class="docs-heading-anchor" href="#Synchronous-run">Synchronous run</a><a id="Synchronous-run-1"></a><a class="docs-heading-anchor-permalink" href="#Synchronous-run" title="Permalink"></a></h2><p>If you want to run your algorithm synchronously you just have to define the <strong>synchronous central step</strong> performed by the central node when receiving answers <code>as::Vector{A}</code> from all the <code>workers</code>...</p><pre><code class="language-julia hljs">@everywhere begin
    # synchronous central step
    (sgd::SGD)(as::Vector{Vector{Float64}}, workers::Vector{Int64}, problem::Any) = sum(as)
end</code></pre><p>...and to add the <code>synchronous=true</code> keyword to <a href="../documentation/#AsynchronousIterativeAlgorithms.start"><code>start</code></a></p><pre><code class="language-julia hljs">history = start(sgd, distributed_problem, stopat; synchronous=true);</code></pre><h2 id="Active-processes"><a class="docs-heading-anchor" href="#Active-processes">Active processes</a><a id="Active-processes-1"></a><a class="docs-heading-anchor-permalink" href="#Active-processes" title="Permalink"></a></h2><p>You can choose which processes are active with the <code>pids</code> keyword</p><pre><code class="language-julia hljs">history = start(sgd, problem_constructor, stopat; pids=[2,3,6]);</code></pre><p>If <code>pids=[1]</code>, a non-distributed (and necessarily synchronous) version of your algorithm will be run.</p><pre><code class="language-julia hljs">history = start(sgd, (pid)-&gt;LRMSE(rand(42,10),rand(42)), stopat; pids=[1], synchronous=true);</code></pre><h2 id="recording_iterated"><a class="docs-heading-anchor" href="#recording_iterated">Recording iterates</a><a id="recording_iterated-1"></a><a class="docs-heading-anchor-permalink" href="#recording_iterated" title="Permalink"></a></h2><p>The queries<code>::Q</code> sent by the central node, along with the iterations, epochs, times at wich they were recorded, are saved at intervals specified by the keyword <code>saveat</code>: every <code>iteration</code> and every <code>epoch</code> (see <a href="../documentation/#AsynchronousIterativeAlgorithms.savenow"><code>savenow</code></a> for custom saving criteria).</p><p>You can set any or all criteria: <code>saveat=(iteration=100, epoch=10)</code> or <code>saveat=(epoch=100,)</code> for example.</p><p>To also save the workers&#39; answers<code>::A</code>, simply add the <code>save_answers=true</code> keyword (see <a href="../documentation/#AsynchronousIterativeAlgorithms.savevalues"><code>savevalues</code></a> and <a href="../documentation/#AsynchronousIterativeAlgorithms.report"><code>report</code></a> to save additional variables during execution).</p><pre><code class="language-julia hljs">history = start(sgd, distributed_problem, stopat; saveat=(iteration=100, epoch=10), save_answers=true);</code></pre><h2 id="custom_execution"><a class="docs-heading-anchor" href="#custom_execution">Customization of <code>start</code>&#39;s execution</a><a id="custom_execution-1"></a><a class="docs-heading-anchor-permalink" href="#custom_execution" title="Permalink"></a></h2><p>Let&#39;s look at a slightly modified version of <code>SGD</code> where we track the <em>&quot;precision&quot;</em> of our iterative algorithm, measured as the distance between the last two iterates.</p><pre><code class="language-julia hljs">@everywhere begin
    using LinearAlgebra

    mutable struct SGDbis&lt;:AbstractAlgorithm{Vector{Float64},Vector{Float64}}
        stepsize::Float64
        previous_q::Vector{Float64}
        precision::Float64  # will hold the distance between the last two iterates
        precisions::Vector{Float64} # record of all the precisions 
        SGDbis(stepsize::Float64) = new(stepsize, Float64[], Inf, Float64[])
    end
    
    # no changes
    function (sgd::SGDbis)(problem::Any)
        sgd.previous_q = rand(problem.n)
    end
    
    # no changes
    function (sgd::SGDbis)(q::Vector{Float64}, problem::Any)
        sgd.stepsize * problem.∇f(q, rand(1:problem.m))
    end
    
    function (sgd::SGDbis)(a::Vector{Float64}, worker::Int64, problem::Any) 
        q = sgd.previous_q - a 
        sgd.precision = norm(q-sgd.previous_q)
        sgd.previous_q = q
    end
end</code></pre><blockquote><p>Recall that we defined <code>const AIA = AsynchronousIterativeAlgorithms</code></p></blockquote><h3 id="[stopnow](@ref)"><a class="docs-heading-anchor" href="#[stopnow](@ref)"><a href="../documentation/#AsynchronousIterativeAlgorithms.stopnow"><code>stopnow</code></a></a><a id="[stopnow](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[stopnow](@ref)" title="Permalink"></a></h3><p>By default, you can specify the any of following stopping criteria through the <code>stopat</code> argument: maximum <code>iteration</code>, <code>epoch</code> and <code>time</code>. If any is met, the execution is stopped.</p><p>If you require additional stopping conditions, for instance <em>&quot;stop at current iteration if the precision is below a threshold&quot;</em> you can define <a href="../documentation/#AsynchronousIterativeAlgorithms.stopnow"><code>stopnow</code></a> on your algorithm:</p><pre><code class="language-julia hljs">function AIA.stopnow(sgd::SGDbis, stopat::NamedTuple) 
    haskey(stopat, :precision) ? sgd.precision ≤ stopat.precision : false
end</code></pre><p>You can now set <code>stopat</code> to <code>(iteration=1000, precision=1e-5)</code> or <code>(precision=1e-5,)</code> for example.</p><h3 id="[savenow](@ref)"><a class="docs-heading-anchor" href="#[savenow](@ref)"><a href="../documentation/#AsynchronousIterativeAlgorithms.savenow"><code>savenow</code></a></a><a id="[savenow](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[savenow](@ref)" title="Permalink"></a></h3><p>By default, you can specify intervals at which <a href="#recording_iterated">some parameters</a> are recorded through the <code>saveat</code> keyword: every <code>iteration</code> and every <code>epoch</code>.</p><p>If you require additional saving checkpoints, for instance <em>&quot;save current iteration if is below a threshold&quot;</em>, you can define <a href="../documentation/#AsynchronousIterativeAlgorithms.savenow"><code>savenow</code></a> on your algorithm:</p><pre><code class="language-julia hljs">function AIA.savenow(sgd::SGDbis, saveat::NamedTuple) 
    haskey(saveat, :precision) ? sgd.precision ≤ saveat.precision : false 
end</code></pre><p>You can now set <code>saveat</code> to <code>(precision=1e-4, time=42)</code> or just <code>(precision=1e-4,)</code> for example.</p><h3 id="[savevalues](@ref)"><a class="docs-heading-anchor" href="#[savevalues](@ref)"><a href="../documentation/#AsynchronousIterativeAlgorithms.savevalues"><code>savevalues</code></a></a><a id="[savevalues](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[savevalues](@ref)" title="Permalink"></a></h3><p><a href="#recording_iterated">By default</a>, at each <code>saveat</code> checkpoint, only queries, iterations, epochs, times, answer count per worker and optionally answers and their provenance.</p><p>If you want to record other values, for instance the precisions computed at the <code>saveat</code> checkpoints, you can define <a href="../documentation/#AsynchronousIterativeAlgorithms.savevalues"><code>savevalues</code></a> on your algorithm:</p><pre><code class="language-julia hljs">function AIA.savevalues(sgd::SGDbis) 
    sgd.precisions = append!(sgd.precisions, [sgd.precision])
end</code></pre><h3 id="[report](@ref)"><a class="docs-heading-anchor" href="#[report](@ref)"><a href="../documentation/#AsynchronousIterativeAlgorithms.report"><code>report</code></a></a><a id="[report](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[report](@ref)" title="Permalink"></a></h3><p>To retrieve any values held by your algorithm, for example the precisions, return them as a <code>NamedTuple</code> in <a href="../documentation/#AsynchronousIterativeAlgorithms.report"><code>report</code></a>:</p><pre><code class="language-julia hljs">function AIA.report(sgd::SGDbis)
    (precisions = sgd.precisions,)
end</code></pre><p>They will now be outputted by <a href="../documentation/#AsynchronousIterativeAlgorithms.start"><code>start</code></a>.</p><h3 id="[progress](@ref)"><a class="docs-heading-anchor" href="#[progress](@ref)"><a href="../documentation/#AsynchronousIterativeAlgorithms.progress"><code>progress</code></a></a><a id="[progress](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[progress](@ref)" title="Permalink"></a></h3><p>When <code>verbose&gt;1</code> a progress bar is displayed. To reflect any progress other than the number of iterations, epochs, and the time, return a value between <code>0</code> to <code>1</code> (<code>1</code> meaning completion) in <a href="../documentation/#AsynchronousIterativeAlgorithms.progress"><code>progress</code></a>:</p><pre><code class="language-julia hljs">function AIA.progress(sgd::SGDbis, stopat::NamedTuple) 
    if haskey(stopat, :precision) 
        sgd.precision == 0 &amp;&amp; return 1.
        return stopat.precision / sgd.precision
    else 
        return 0.
    end
end</code></pre><h3 id="[showvalues](@ref)"><a class="docs-heading-anchor" href="#[showvalues](@ref)"><a href="../documentation/#AsynchronousIterativeAlgorithms.showvalues"><code>showvalues</code></a></a><a id="[showvalues](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[showvalues](@ref)" title="Permalink"></a></h3><p>Below the progress bar, by default, the number of iterations, epochs and answers-per-worker count are displayed. If you want to keep track of other values, return them as a <code>Vector</code> of <code>Tuple{Symbol,Any}</code> in <a href="../documentation/#AsynchronousIterativeAlgorithms.savevalues"><code>savevalues</code></a>:</p><pre><code class="language-julia hljs">function AIA.showvalues(sgd::SGDbis)
    [(:precision, round(sgd.precision; sigdigits=4))]
end</code></pre><h2 id="Handling-worker-failures"><a class="docs-heading-anchor" href="#Handling-worker-failures">Handling worker failures</a><a id="Handling-worker-failures-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-worker-failures" title="Permalink"></a></h2><p>If you expect some workers to fail but still want the algorithm to continue running, you can set the <code>resilience</code> parameter to the maximum number of worker failures you can tolerate before the execution is terminated.</p><h2 id="algorithm_wrappers"><a class="docs-heading-anchor" href="#algorithm_wrappers">Algorithm wrappers</a><a id="algorithm_wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#algorithm_wrappers" title="Permalink"></a></h2><p>You are free to create your own algorithms, but if you&#39;re interested in <em>aggregation algorithms</em>, you can use an implementation provided in this library. The iteration of such an algorithm performs the following computation:</p><p class="math-container">\[q_j \longleftarrow \textrm{query}(\underset{i \in \textrm{connected}}{\textrm{aggregate}}(a_i))\ \ \textrm{where }\ \ a_i = \textrm{answer}(q_i)\]</p><p>where <span>$q_j$</span> is computed by the worker upon reception of <span>$\textrm{answer}(q_i)$</span> from worker <span>$j$</span> and where <span>$connected$</span> are the list of workers that have answered.</p><p>The <a href="../documentation/#AsynchronousIterativeAlgorithms.AggregationAlgorithm"><code>AggregationAlgorithm</code></a> in this library requires you to define four methods: <code>initialize</code>, <code>query</code>, <code>answer</code>, and <code>aggregate</code>. Here&#39;s an example showing the required signatures of these three methods:</p><pre><code class="language-julia hljs">@everywhere begin 
    using Statistics

    struct ToBeAggregatedGD &lt;: AbstractAlgorithm{Vector{Float64},Vector{Float64}}
        q1::Vector{Float64}
        stepsize::Float64 
    end

    AIA.initialize(tba::ToBeAggregatedGD, problem::Any) = tba.q1
    AIA.aggregate(tba::ToBeAggregatedGD, a::Vector{Vector{Float64}}, connected::Vector{Int64}) = mean(a)            
    AIA.query(tba::ToBeAggregatedGD, a::Vector{Float64}, problem::Any) = a
    AIA.answer(tba::ToBeAggregatedGD, q::Vector{Float64}, problem::Any) = q - tba.stepsize * problem.∇f(q)
end 

algorithm = AggregationAlgorithm(ToBeAggregatedGD(rand(10), 0.01); pids=workers())

history = start(algorithm, distributed_problem, (epoch=100,));</code></pre><p><strong>Memory limitation:</strong> At any point in time, the central worker should have access must have access to the latest answers <span>$a_i$</span> from <em>all</em> the connected workers. This means storing a lot of <span>$a_i$</span> if we use many workers. There is a workaround when the aggregation operation is an <em>average</em>. In this case, only the equivalent of one answer needs to be saved on the central node, regardless of the number of workers.</p><p><a href="../documentation/#AsynchronousIterativeAlgorithms.AveragingAlgorithm"><code>AveragingAlgorithm</code></a> implements this memory optimization. Here you only need to define <code>initialize</code>, <code>query</code>, the <code>answer</code></p><pre><code class="language-julia hljs">@everywhere begin 
    struct ToBeAveragedGD &lt;: AbstractAlgorithm{Vector{Float64},Vector{Float64}}
        q1::Vector{Float64}
        stepsize::Float64 
    end

    AIA.initialize(tba::ToBeAveragedGD, problem::Any) = tba.q1
    AIA.query(tba::ToBeAveragedGD, a::Vector{Float64}, problem::Any) = a
    AIA.answer(tba::ToBeAveragedGD, q::Vector{Float64}, problem::Any) = q - tba.stepsize * problem.∇f(q)
end 

algorithm = AveragingAlgorithm(ToBeAveragedGD(rand(10), 0.01); pids=workers(), weights=ones(nworkers()))

history = start(algorithm, distributed_problem, (epoch=100,));</code></pre><p>Note that you can implement the <a href="#custom_execution">custom callbacks</a> on both these algorithms by defining them on your algorithm:</p><pre><code class="language-julia hljs">report(::ToBeAggregatedGD) = # do something</code></pre><hr/><p>Wow you read all this! Hope you find this library helpful and look forward to seeing how you put it to use!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../documentation/">Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 22 February 2023 14:21">Wednesday 22 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
